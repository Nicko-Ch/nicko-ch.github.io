<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Go高级编程 - Golang逃逸分析 | &gt; $ cd /home</title>
<meta name="keywords" content="Go, Golang" />
<meta name="description" content="Golang逃逸分析 1、 原理 go语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做**逃逸分析(escape analysis)**，**当发现变量的作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆。**
2、如何分析 2.1、案例 package main func foo(arg_val int) (*int) { var foo_val1 int = 11; var foo_val2 int = 12; var foo_val3 int = 13; var foo_val4 int = 14; var foo_val5 int = 15; //此处循环是防止go编译器将foo优化成inline(内联函数)  //如果是内联函数，main调用foo将是原地展开，所以foo_val1-5相当于main作用域的变量  //即使foo_val3发生逃逸，地址与其他也是连续的  for i := 0; i &lt; 5; i&#43;&#43; { println(&amp;arg_val, &amp;foo_val1, &amp;foo_val2, &amp;foo_val3, &amp;foo_val4, &amp;foo_val5) } //返回foo_val3给main函数  return &amp;foo_val3; } func main() { main_val := foo(666) println(*main_val, main_val) } 运行结果">
<meta name="author" content="">
<link rel="canonical" href="https://nicko-ch.github.io/posts/golang/20220106-go%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-golang%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.0459a4ebf56f381ae411e97a494635ba7ce9db741ff9a2cfbf7e12366bf1e73d.css" integrity="sha256-BFmk6/VvOBrkEel6SUY1unzp23Qf&#43;aLPv34SNmvx5z0=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.6f62d19b78590241c3e007a10f91f45f95ce2528ca8f3e33c542e95f8ed5691f.js" integrity="sha256-b2LRm3hZAkHD4AehD5H0X5XOJSjKjz4zxULpX47VaR8="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://nicko-ch.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://nicko-ch.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://nicko-ch.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://nicko-ch.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://nicko-ch.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.88.0" />
<meta property="og:title" content="Go高级编程 - Golang逃逸分析" />
<meta property="og:description" content="Golang逃逸分析 1、 原理 go语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做**逃逸分析(escape analysis)**，**当发现变量的作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆。**
2、如何分析 2.1、案例 package main func foo(arg_val int) (*int) { var foo_val1 int = 11; var foo_val2 int = 12; var foo_val3 int = 13; var foo_val4 int = 14; var foo_val5 int = 15; //此处循环是防止go编译器将foo优化成inline(内联函数)  //如果是内联函数，main调用foo将是原地展开，所以foo_val1-5相当于main作用域的变量  //即使foo_val3发生逃逸，地址与其他也是连续的  for i := 0; i &lt; 5; i&#43;&#43; { println(&amp;arg_val, &amp;foo_val1, &amp;foo_val2, &amp;foo_val3, &amp;foo_val4, &amp;foo_val5) } //返回foo_val3给main函数  return &amp;foo_val3; } func main() { main_val := foo(666) println(*main_val, main_val) } 运行结果" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://nicko-ch.github.io/posts/golang/20220106-go%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-golang%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-06T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2022-01-06T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go高级编程 - Golang逃逸分析"/>
<meta name="twitter:description" content="Golang逃逸分析 1、 原理 go语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做**逃逸分析(escape analysis)**，**当发现变量的作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆。**
2、如何分析 2.1、案例 package main func foo(arg_val int) (*int) { var foo_val1 int = 11; var foo_val2 int = 12; var foo_val3 int = 13; var foo_val4 int = 14; var foo_val5 int = 15; //此处循环是防止go编译器将foo优化成inline(内联函数)  //如果是内联函数，main调用foo将是原地展开，所以foo_val1-5相当于main作用域的变量  //即使foo_val3发生逃逸，地址与其他也是连续的  for i := 0; i &lt; 5; i&#43;&#43; { println(&amp;arg_val, &amp;foo_val1, &amp;foo_val2, &amp;foo_val3, &amp;foo_val4, &amp;foo_val5) } //返回foo_val3给main函数  return &amp;foo_val3; } func main() { main_val := foo(666) println(*main_val, main_val) } 运行结果"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://nicko-ch.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Go高级编程 - Golang逃逸分析",
      "item": "https://nicko-ch.github.io/posts/golang/20220106-go%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-golang%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go高级编程 - Golang逃逸分析",
  "name": "Go高级编程 - Golang逃逸分析",
  "description": "Golang逃逸分析 1、 原理 go语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做**逃逸分析(escape analysis)**，**当发现变量的作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆。**\n2、如何分析 2.1、案例 package main func foo(arg_val int) (*int) { var foo_val1 int = 11; var foo_val2 int = 12; var foo_val3 int = 13; var foo_val4 int = 14; var foo_val5 int = 15; //此处循环是防止go编译器将foo优化成inline(内联函数)  //如果是内联函数，main调用foo将是原地展开，所以foo_val1-5相当于main作用域的变量  //即使foo_val3发生逃逸，地址与其他也是连续的  for i := 0; i \u0026lt; 5; i++ { println(\u0026amp;arg_val, \u0026amp;foo_val1, \u0026amp;foo_val2, \u0026amp;foo_val3, \u0026amp;foo_val4, \u0026amp;foo_val5) } //返回foo_val3给main函数  return \u0026amp;foo_val3; } func main() { main_val := foo(666) println(*main_val, main_val) } 运行结果",
  "keywords": [
    "Go", "Golang"
  ],
  "articleBody": "Golang逃逸分析 1、 原理 go语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做**逃逸分析(escape analysis)**，**当发现变量的作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆。**\n2、如何分析 2.1、案例 package main func foo(arg_val int) (*int) { var foo_val1 int = 11; var foo_val2 int = 12; var foo_val3 int = 13; var foo_val4 int = 14; var foo_val5 int = 15; //此处循环是防止go编译器将foo优化成inline(内联函数)  //如果是内联函数，main调用foo将是原地展开，所以foo_val1-5相当于main作用域的变量  //即使foo_val3发生逃逸，地址与其他也是连续的  for i := 0; i 5; i++ { println(\u0026arg_val, \u0026foo_val1, \u0026foo_val2, \u0026foo_val3, \u0026foo_val4, \u0026foo_val5) } //返回foo_val3给main函数  return \u0026foo_val3; } func main() { main_val := foo(666) println(*main_val, main_val) } 运行结果\n$ go run pro_2.go 0xc000030758 0xc000030738 0xc000030730 0xc000082000 0xc000030728 0xc000030720 0xc000030758 0xc000030738 0xc000030730 0xc000082000 0xc000030728 0xc000030720 0xc000030758 0xc000030738 0xc000030730 0xc000082000 0xc000030728 0xc000030720 0xc000030758 0xc000030738 0xc000030730 0xc000082000 0xc000030728 0xc000030720 0xc000030758 0xc000030738 0xc000030730 0xc000082000 0xc000030728 0xc000030720 13 0xc000082000 结论：\n可以看出fool_val3是返回main的局部变量，明显与fool_val1-4不是连续的地址\n2.2、go tool compile -m分析 我们用go tool compile -m测试一下\n$ go tool compile -m pro_2.go pro_2.go:24:6: can inline main pro_2.go:7:9: moved to heap: foo_val3 果然,在编译的时候, foo_val3具有被编译器判定为逃逸变量, 将foo_val3放在堆中开辟.\n我们在用汇编证实一下:\n$ go tool compile -S pro_2.go  pro_2.S 打开pro_2.S文件, 搜索runtime.newobject关键字\n... 16 0x0021 00033 (pro_2.go:5) PCDATA $0, $0 17 0x0021 00033 (pro_2.go:5) PCDATA $1, $0 18 0x0021 00033 (pro_2.go:5) MOVQ $11, \"\".foo_val1+48(SP) 19 0x002a 00042 (pro_2.go:6) MOVQ $12, \"\".foo_val2+40(SP) 20 0x0033 00051 (pro_2.go:7) PCDATA $0, $1 21 0x0033 00051 (pro_2.go:7) LEAQ type.int(SB), AX 22 0x003a 00058 (pro_2.go:7) PCDATA $0, $0 23 0x003a 00058 (pro_2.go:7) MOVQ AX, (SP) 24 0x003e 00062 (pro_2.go:7) CALL runtime.newobject(SB) //foo_val3是被new出来的 25 0x0043 00067 (pro_2.go:7) PCDATA $0, $1 26 0x0043 00067 (pro_2.go:7) MOVQ 8(SP), AX 27 0x0048 00072 (pro_2.go:7) PCDATA $1, $1 28 0x0048 00072 (pro_2.go:7) MOVQ AX, \"\".\u0026foo_val3+56(SP) 29 0x004d 00077 (pro_2.go:7) MOVQ $13, (AX) 30 0x0054 00084 (pro_2.go:8) MOVQ $14, \"\".foo_val4+32(SP) 31 0x005d 00093 (pro_2.go:9) MOVQ $15, \"\".foo_val5+24(SP) 32 0x0066 00102 (pro_2.go:9) XORL CX, CX 33 0x0068 00104 (pro_2.go:15) JMP 252 ... 看出来, foo_val3是被runtime.newobject()在堆空间开辟的, 而不是像其他几个是基于地址偏移的开辟的栈空间.\n3、逃逸范例 3.1、 逃逸规则 **一般给引用类型进行赋值，则可能出现逃逸。**原理解析为当用户引用一个引用类型的对象是，已经是通过指针间接访问，如果再访问引用类型的对象的成员，则会出现二次间接引用，这就极大可能出现逃逸现象。\nGo语言中的引用类型有\n func（函数类型） interface（接口类型） slice（切片类型） map（字典类型） channel（管道类型） *（指针类型）等。  3.2、逃逸案例 案例一、 []interface{}数据类型，通过[]赋值必定会出现逃逸。\npackage main func main() { data := []interface{}{100, 200} data[0] = 100 } 我们通过编译看看逃逸结果\naceld:test ldb$ go tool compile -m 1.go 1.go:3:6: can inline main 1.go:4:23: []interface {}{...} does not escape 1.go:4:24: 100 does not escape 1.go:4:29: 200 does not escape 1.go:6:10: 100 escapes to heap 我们能看到，data[0] = 100 发生了逃逸现象。\n案例二、 map[string]interface{}类型尝试通过赋值，必定会出现逃逸。\npackage main func main() { data := make(map[string]interface{}) data[\"key\"] = 200 } 我们通过编译看看逃逸结果\naceld:test ldb$ go tool compile -m 2.go 2.go:3:6: can inline main 2.go:4:14: make(map[string]interface {}) does not escape 2.go:6:14: 200 escapes to heap 我们能看到，data[\"key\"] = 200 发生了逃逸。\n案例三、 map[interface{}]interface{}类型尝试通过赋值，会导致key和value的赋值，出现逃逸。\npackage main func main() { data := make(map[interface{}]interface{}) data[100] = 200 } 我们通过编译看看逃逸结果\naceld:test ldb$ go tool compile -m 3.go 3.go:3:6: can inline main 3.go:4:14: make(map[interface {}]interface {}) does not escape 3.go:6:6: 100 escapes to heap 3.go:6:12: 200 escapes to heap 我们能看到，data[100] = 200 中，100和200均发生了逃逸。\n案例四、 map[string][]string数据类型，赋值会发生[]string发生逃逸。\npackage main func main() { data := make(map[string][]string) data[\"key\"] = []string{\"value\"} } 我们通过编译看看逃逸结果\naceld:test ldb$ go tool compile -m 4.go 4.go:3:6: can inline main 4.go:4:14: make(map[string][]string) does not escape 4.go:6:24: []string{...} escapes to heap 我们能看到，[]string{...}切片发生了逃逸。\n案例五、 []*int数据类型，赋值的右值会发生逃逸现象。\npackage main func main() { a := 10 data := []*int{nil} data[0] = \u0026a } 我们通过编译看看逃逸结果\naceld:test ldb$ go tool compile -m 5.go 5.go:3:6: can inline main 5.go:4:2: moved to heap: a 5.go:6:16: []*int{...} does not escape 其中 moved to heap: a，最终将变量a 移动到了堆上。\n案例六、 func(*int)函数类型，进行函数赋值，会使传递的形参出现逃逸现象。\npackage main import \"fmt\" func foo(a *int) { return } func main() { data := 10 f := foo f(\u0026data) fmt.Println(data) } 我们通过编译看看逃逸结果\naceld:test ldb$ go tool compile -m 6.go 6.go:5:6: can inline foo 6.go:12:3: inlining call to foo 6.go:14:13: inlining call to fmt.Println 6.go:5:10: a does not escape 6.go:14:13: data escapes to heap 6.go:14:13: []interface {}{...} does not escape :1: .this does not escape 我们会看到data已经被逃逸到堆上。\n案例七、 func([]string): 函数类型，进行[]string{\"value\"}赋值，会使传递的参数出现逃逸现象。\npackage main import \"fmt\" func foo(a []string) { return } func main() { s := []string{\"aceld\"} foo(s) fmt.Println(s) } 我们通过编译看看逃逸结果\naceld:test ldb$ go tool compile -m 7.go 7.go:5:6: can inline foo 7.go:11:5: inlining call to foo 7.go:13:13: inlining call to fmt.Println 7.go:5:10: a does not escape 7.go:10:15: []string{...} escapes to heap 7.go:13:13: s escapes to heap 7.go:13:13: []interface {}{...} does not escape :1: .this does not escape 我们看到 s escapes to heap，s被逃逸到堆上。\n案例八、 chan []string数据类型，想当前channel中传输[]string{\"value\"}会发生逃逸现象。\npackage main func main() { ch := make(chan []string) s := []string{\"aceld\"} go func() { ch  s }() } 我们通过编译看看逃逸结果\naceld:test ldb$ go tool compile -m 8.go 8.go:8:5: can inline main.func1 8.go:6:15: []string{...} escapes to heap 8.go:8:5: func literal escapes to heap 我们看到[]string{...} escapes to heap, s被逃逸到堆上。\n",
  "wordCount" : "705",
  "inLanguage": "en",
  "datePublished": "2022-01-06T00:00:00Z",
  "dateModified": "2022-01-06T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://nicko-ch.github.io/posts/golang/20220106-go%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-golang%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "\u003e $ cd /home",
    "logo": {
      "@type": "ImageObject",
      "url": "https://nicko-ch.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://nicko-ch.github.io/" accesskey="h" title="&gt; $ cd /home (Alt + H)">&gt; $ cd /home</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://nicko-ch.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://nicko-ch.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://nicko-ch.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://nicko-ch.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://nicko-ch.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://nicko-ch.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://nicko-ch.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://nicko-ch.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      Go高级编程 - Golang逃逸分析
    </h1>
    <div class="post-meta">January 6, 2022&nbsp;·&nbsp;4 min
</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <div class="details">Table of Contents</div>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#golang%e9%80%83%e9%80%b8%e5%88%86%e6%9e%90" aria-label="Golang逃逸分析">Golang逃逸分析</a></li>
                <li>
                    <a href="#1-%e5%8e%9f%e7%90%86" aria-label="1、 原理">1、 原理</a></li>
                <li>
                    <a href="#2%e5%a6%82%e4%bd%95%e5%88%86%e6%9e%90" aria-label="2、如何分析">2、如何分析</a><ul>
                        
                <li>
                    <a href="#21%e6%a1%88%e4%be%8b" aria-label="2.1、案例">2.1、案例</a></li>
                <li>
                    <a href="#22go-tool-compile--m%e5%88%86%e6%9e%90" aria-label="2.2、go tool compile -m分析">2.2、go tool compile -m分析</a></li></ul>
                </li>
                <li>
                    <a href="#3%e9%80%83%e9%80%b8%e8%8c%83%e4%be%8b" aria-label="3、逃逸范例">3、逃逸范例</a><ul>
                        
                <li>
                    <a href="#31-%e9%80%83%e9%80%b8%e8%a7%84%e5%88%99" aria-label="3.1、 逃逸规则">3.1、 逃逸规则</a></li>
                <li>
                    <a href="#32%e9%80%83%e9%80%b8%e6%a1%88%e4%be%8b" aria-label="3.2、逃逸案例">3.2、逃逸案例</a><ul>
                        
                <li>
                    <a href="#%e6%a1%88%e4%be%8b%e4%b8%80" aria-label="案例一、">案例一、</a></li>
                <li>
                    <a href="#%e6%a1%88%e4%be%8b%e4%ba%8c" aria-label="案例二、">案例二、</a></li>
                <li>
                    <a href="#%e6%a1%88%e4%be%8b%e4%b8%89" aria-label="案例三、">案例三、</a></li>
                <li>
                    <a href="#%e6%a1%88%e4%be%8b%e5%9b%9b" aria-label="案例四、">案例四、</a></li>
                <li>
                    <a href="#%e6%a1%88%e4%be%8b%e4%ba%94" aria-label="案例五、">案例五、</a></li>
                <li>
                    <a href="#%e6%a1%88%e4%be%8b%e5%85%ad" aria-label="案例六、">案例六、</a></li>
                <li>
                    <a href="#%e6%a1%88%e4%be%8b%e4%b8%83" aria-label="案例七、">案例七、</a></li>
                <li>
                    <a href="#%e6%a1%88%e4%be%8b%e5%85%ab" aria-label="案例八、">案例八、</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="golang逃逸分析">Golang逃逸分析<a hidden class="anchor" aria-hidden="true" href="#golang逃逸分析">#</a></h1>
<h1 id="1-原理">1、 原理<a hidden class="anchor" aria-hidden="true" href="#1-原理">#</a></h1>
<p>go语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做**<code>逃逸分析</code>(escape analysis)**，**当发现变量的作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆。**</p>
<h1 id="2如何分析">2、如何分析<a hidden class="anchor" aria-hidden="true" href="#2如何分析">#</a></h1>
<h2 id="21案例">2.1、案例<a hidden class="anchor" aria-hidden="true" href="#21案例">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">foo</span>(<span style="color:#a6e22e">arg_val</span> <span style="color:#66d9ef">int</span>) (<span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>) {

    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">foo_val1</span> <span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">11</span>;
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">foo_val2</span> <span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">12</span>;
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">foo_val3</span> <span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">13</span>;
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">foo_val4</span> <span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">14</span>;
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">foo_val5</span> <span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">15</span>;

    <span style="color:#75715e">//此处循环是防止go编译器将foo优化成inline(内联函数)
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//如果是内联函数，main调用foo将是原地展开，所以foo_val1-5相当于main作用域的变量
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//即使foo_val3发生逃逸，地址与其他也是连续的
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">5</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        println(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">arg_val</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">foo_val1</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">foo_val2</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">foo_val3</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">foo_val4</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">foo_val5</span>)
    }

    <span style="color:#75715e">//返回foo_val3给main函数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">foo_val3</span>;
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">main_val</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">foo</span>(<span style="color:#ae81ff">666</span>)

    println(<span style="color:#f92672">*</span><span style="color:#a6e22e">main_val</span>, <span style="color:#a6e22e">main_val</span>)
}
</code></pre></div><p>运行结果</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ go run pro_2.go 
0xc000030758 0xc000030738 0xc000030730 0xc000082000 0xc000030728 0xc000030720
0xc000030758 0xc000030738 0xc000030730 0xc000082000 0xc000030728 0xc000030720
0xc000030758 0xc000030738 0xc000030730 0xc000082000 0xc000030728 0xc000030720
0xc000030758 0xc000030738 0xc000030730 0xc000082000 0xc000030728 0xc000030720
0xc000030758 0xc000030738 0xc000030730 0xc000082000 0xc000030728 0xc000030720
<span style="color:#ae81ff">13</span> 0xc000082000
</code></pre></div><p>结论：</p>
<p>可以看出<code>fool_val3</code>是返回main的局部变量，明显与<code>fool_val1-4</code>不是连续的地址</p>
<h2 id="22go-tool-compile--m分析">2.2、go tool compile -m分析<a hidden class="anchor" aria-hidden="true" href="#22go-tool-compile--m分析">#</a></h2>
<p>我们用<code>go tool compile -m</code>测试一下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ go tool compile -m pro_2.go
pro_2.go:24:6: can inline main
pro_2.go:7:9: moved to heap: foo_val3
</code></pre></div><p>果然,在编译的时候, <code>foo_val3</code>具有被编译器判定为逃逸变量, 将<code>foo_val3</code>放在堆中开辟.</p>
<p>我们在用汇编证实一下:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ go tool compile -S pro_2.go &gt; pro_2.S
</code></pre></div><p>打开pro_2.S文件, 搜索<code>runtime.newobject</code>关键字</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">...
 <span style="color:#ae81ff">16</span>     0x0021 <span style="color:#ae81ff">00033</span> <span style="color:#f92672">(</span>pro_2.go:5<span style="color:#f92672">)</span>   PCDATA  $0, $0
 <span style="color:#ae81ff">17</span>     0x0021 <span style="color:#ae81ff">00033</span> <span style="color:#f92672">(</span>pro_2.go:5<span style="color:#f92672">)</span>   PCDATA  $1, $0
 <span style="color:#ae81ff">18</span>     0x0021 <span style="color:#ae81ff">00033</span> <span style="color:#f92672">(</span>pro_2.go:5<span style="color:#f92672">)</span>   MOVQ    $11, <span style="color:#e6db74">&#34;&#34;</span>.foo_val1+48<span style="color:#f92672">(</span>SP<span style="color:#f92672">)</span>
 <span style="color:#ae81ff">19</span>     0x002a <span style="color:#ae81ff">00042</span> <span style="color:#f92672">(</span>pro_2.go:6<span style="color:#f92672">)</span>   MOVQ    $12, <span style="color:#e6db74">&#34;&#34;</span>.foo_val2+40<span style="color:#f92672">(</span>SP<span style="color:#f92672">)</span>
 <span style="color:#ae81ff">20</span>     0x0033 <span style="color:#ae81ff">00051</span> <span style="color:#f92672">(</span>pro_2.go:7<span style="color:#f92672">)</span>   PCDATA  $0, $1
 <span style="color:#ae81ff">21</span>     0x0033 <span style="color:#ae81ff">00051</span> <span style="color:#f92672">(</span>pro_2.go:7<span style="color:#f92672">)</span>   LEAQ    type.int<span style="color:#f92672">(</span>SB<span style="color:#f92672">)</span>, AX
 <span style="color:#ae81ff">22</span>     0x003a <span style="color:#ae81ff">00058</span> <span style="color:#f92672">(</span>pro_2.go:7<span style="color:#f92672">)</span>   PCDATA  $0, $0
 <span style="color:#ae81ff">23</span>     0x003a <span style="color:#ae81ff">00058</span> <span style="color:#f92672">(</span>pro_2.go:7<span style="color:#f92672">)</span>   MOVQ    AX, <span style="color:#f92672">(</span>SP<span style="color:#f92672">)</span>
 <span style="color:#ae81ff">24</span>     0x003e <span style="color:#ae81ff">00062</span> <span style="color:#f92672">(</span>pro_2.go:7<span style="color:#f92672">)</span>   CALL    runtime.newobject<span style="color:#f92672">(</span>SB<span style="color:#f92672">)</span>  //foo_val3是被new出来的
 <span style="color:#ae81ff">25</span>     0x0043 <span style="color:#ae81ff">00067</span> <span style="color:#f92672">(</span>pro_2.go:7<span style="color:#f92672">)</span>   PCDATA  $0, $1
 <span style="color:#ae81ff">26</span>     0x0043 <span style="color:#ae81ff">00067</span> <span style="color:#f92672">(</span>pro_2.go:7<span style="color:#f92672">)</span>   MOVQ    8<span style="color:#f92672">(</span>SP<span style="color:#f92672">)</span>, AX
 <span style="color:#ae81ff">27</span>     0x0048 <span style="color:#ae81ff">00072</span> <span style="color:#f92672">(</span>pro_2.go:7<span style="color:#f92672">)</span>   PCDATA  $1, $1
 <span style="color:#ae81ff">28</span>     0x0048 <span style="color:#ae81ff">00072</span> <span style="color:#f92672">(</span>pro_2.go:7<span style="color:#f92672">)</span>   MOVQ    AX, <span style="color:#e6db74">&#34;&#34;</span>.&amp;foo_val3+56<span style="color:#f92672">(</span>SP<span style="color:#f92672">)</span>
 <span style="color:#ae81ff">29</span>     0x004d <span style="color:#ae81ff">00077</span> <span style="color:#f92672">(</span>pro_2.go:7<span style="color:#f92672">)</span>   MOVQ    $13, <span style="color:#f92672">(</span>AX<span style="color:#f92672">)</span>
 <span style="color:#ae81ff">30</span>     0x0054 <span style="color:#ae81ff">00084</span> <span style="color:#f92672">(</span>pro_2.go:8<span style="color:#f92672">)</span>   MOVQ    $14, <span style="color:#e6db74">&#34;&#34;</span>.foo_val4+32<span style="color:#f92672">(</span>SP<span style="color:#f92672">)</span>
 <span style="color:#ae81ff">31</span>     0x005d <span style="color:#ae81ff">00093</span> <span style="color:#f92672">(</span>pro_2.go:9<span style="color:#f92672">)</span>   MOVQ    $15, <span style="color:#e6db74">&#34;&#34;</span>.foo_val5+24<span style="color:#f92672">(</span>SP<span style="color:#f92672">)</span>
 <span style="color:#ae81ff">32</span>     0x0066 <span style="color:#ae81ff">00102</span> <span style="color:#f92672">(</span>pro_2.go:9<span style="color:#f92672">)</span>   XORL    CX, CX
 <span style="color:#ae81ff">33</span>     0x0068 <span style="color:#ae81ff">00104</span> <span style="color:#f92672">(</span>pro_2.go:15<span style="color:#f92672">)</span>  JMP <span style="color:#ae81ff">252</span>
 ...
</code></pre></div><p>看出来, foo_val3是被runtime.newobject()在堆空间开辟的, 而不是像其他几个是基于地址偏移的开辟的栈空间.</p>
<h1 id="3逃逸范例">3、逃逸范例<a hidden class="anchor" aria-hidden="true" href="#3逃逸范例">#</a></h1>
<h2 id="31-逃逸规则">3.1、 逃逸规则<a hidden class="anchor" aria-hidden="true" href="#31-逃逸规则">#</a></h2>
<p>**一般给引用类型进行赋值，则可能出现逃逸。**原理解析为当用户引用一个引用类型的对象是，已经是通过指针间接访问，如果再访问引用类型的对象的成员，则会出现二次间接引用，这就极大可能出现逃逸现象。</p>
<p>Go语言中的引用类型有</p>
<ul>
<li><code>func</code>（函数类型）</li>
<li><code>interface</code>（接口类型）</li>
<li><code>slice</code>（切片类型）</li>
<li><code>map</code>（字典类型）</li>
<li><code>channel</code>（管道类型）</li>
<li><code>*</code>（指针类型）等。</li>
</ul>
<h2 id="32逃逸案例">3.2、逃逸案例<a hidden class="anchor" aria-hidden="true" href="#32逃逸案例">#</a></h2>
<h3 id="案例一">案例一、<a hidden class="anchor" aria-hidden="true" href="#案例一">#</a></h3>
<p><code>[]interface{}</code>数据类型，通过<code>[]</code>赋值必定会出现逃逸。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">data</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">interface</span>{}{<span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">200</span>}
    <span style="color:#a6e22e">data</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">100</span>
}
</code></pre></div><p>我们通过编译看看逃逸结果</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">aceld:test ldb$ go tool compile -m 1.go

1.go:3:6: can inline main
1.go:4:23: <span style="color:#f92672">[]</span>interface <span style="color:#f92672">{}{</span>...<span style="color:#f92672">}</span> does not escape
1.go:4:24: <span style="color:#ae81ff">100</span> does not escape
1.go:4:29: <span style="color:#ae81ff">200</span> does not escape
1.go:6:10: <span style="color:#ae81ff">100</span> escapes to heap
</code></pre></div><p>我们能看到，<code>data[0] = 100</code> 发生了逃逸现象。</p>
<h3 id="案例二">案例二、<a hidden class="anchor" aria-hidden="true" href="#案例二">#</a></h3>
<p><code>map[string]interface{}</code>类型尝试通过赋值，必定会出现逃逸。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">data</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{})
    <span style="color:#a6e22e">data</span>[<span style="color:#e6db74">&#34;key&#34;</span>] = <span style="color:#ae81ff">200</span>
}
</code></pre></div><p>我们通过编译看看逃逸结果</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">aceld:test ldb$ go tool compile -m 2.go
2.go:3:6: can inline main
2.go:4:14: make<span style="color:#f92672">(</span>map<span style="color:#f92672">[</span>string<span style="color:#f92672">]</span>interface <span style="color:#f92672">{})</span> does not escape
2.go:6:14: <span style="color:#ae81ff">200</span> escapes to heap
</code></pre></div><p>我们能看到，<code>data[&quot;key&quot;] = 200</code> 发生了逃逸。</p>
<h3 id="案例三">案例三、<a hidden class="anchor" aria-hidden="true" href="#案例三">#</a></h3>
<p><code>map[interface{}]interface{}</code>类型尝试通过赋值，会导致key和value的赋值，出现逃逸。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">data</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">interface</span>{}]<span style="color:#66d9ef">interface</span>{})
    <span style="color:#a6e22e">data</span>[<span style="color:#ae81ff">100</span>] = <span style="color:#ae81ff">200</span>
}
</code></pre></div><p>我们通过编译看看逃逸结果</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">aceld:test ldb$ go tool compile -m 3.go
3.go:3:6: can inline main
3.go:4:14: make<span style="color:#f92672">(</span>map<span style="color:#f92672">[</span>interface <span style="color:#f92672">{}]</span>interface <span style="color:#f92672">{})</span> does not escape
3.go:6:6: <span style="color:#ae81ff">100</span> escapes to heap
3.go:6:12: <span style="color:#ae81ff">200</span> escapes to heap
</code></pre></div><p>我们能看到，<code>data[100] = 200</code> 中，100和200均发生了逃逸。</p>
<h3 id="案例四">案例四、<a hidden class="anchor" aria-hidden="true" href="#案例四">#</a></h3>
<p><code>map[string][]string</code>数据类型，赋值会发生<code>[]string</code>发生逃逸。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
<span style="color:#a6e22e">data</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>][]<span style="color:#66d9ef">string</span>)
<span style="color:#a6e22e">data</span>[<span style="color:#e6db74">&#34;key&#34;</span>] = []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;value&#34;</span>}
}
</code></pre></div><p>我们通过编译看看逃逸结果</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">aceld:test ldb$ go tool compile -m 4.go
4.go:3:6: can inline main
4.go:4:14: make<span style="color:#f92672">(</span>map<span style="color:#f92672">[</span>string<span style="color:#f92672">][]</span>string<span style="color:#f92672">)</span> does not escape
4.go:6:24: <span style="color:#f92672">[]</span>string<span style="color:#f92672">{</span>...<span style="color:#f92672">}</span> escapes to heap
</code></pre></div><p>我们能看到，<code>[]string{...}</code>切片发生了逃逸。</p>
<h3 id="案例五">案例五、<a hidden class="anchor" aria-hidden="true" href="#案例五">#</a></h3>
<p><code>[]*int</code>数据类型，赋值的右值会发生逃逸现象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">10</span>
    <span style="color:#a6e22e">data</span> <span style="color:#f92672">:=</span> []<span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>{<span style="color:#66d9ef">nil</span>}
    <span style="color:#a6e22e">data</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">a</span>
}
</code></pre></div><p>我们通过编译看看逃逸结果</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">aceld:test ldb$ go tool compile -m 5.go
5.go:3:6: can inline main
5.go:4:2: moved to heap: a
5.go:6:16: <span style="color:#f92672">[]</span>*int<span style="color:#f92672">{</span>...<span style="color:#f92672">}</span> does not escape
</code></pre></div><p>其中 <code>moved to heap: a</code>，最终将变量a 移动到了堆上。</p>
<h3 id="案例六">案例六、<a hidden class="anchor" aria-hidden="true" href="#案例六">#</a></h3>
<p><code>func(*int)</code>函数类型，进行函数赋值，会使传递的形参出现逃逸现象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">foo</span>(<span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>) {
    <span style="color:#66d9ef">return</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">data</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">10</span>
    <span style="color:#a6e22e">f</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">foo</span>
    <span style="color:#a6e22e">f</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">data</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">data</span>)
}
</code></pre></div><p>我们通过编译看看逃逸结果</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">aceld:test ldb$ go tool compile -m 6.go
6.go:5:6: can inline foo
6.go:12:3: inlining call to foo
6.go:14:13: inlining call to fmt.Println
6.go:5:10: a does not escape
6.go:14:13: data escapes to heap
6.go:14:13: <span style="color:#f92672">[]</span>interface <span style="color:#f92672">{}{</span>...<span style="color:#f92672">}</span> does not escape
:1: .this does not escape
</code></pre></div><p>我们会看到data已经被逃逸到堆上。</p>
<h3 id="案例七">案例七、<a hidden class="anchor" aria-hidden="true" href="#案例七">#</a></h3>
<p><code>func([]string)</code>: 函数类型，进行<code>[]string{&quot;value&quot;}</code>赋值，会使传递的参数出现逃逸现象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">foo</span>(<span style="color:#a6e22e">a</span> []<span style="color:#66d9ef">string</span>) {
    <span style="color:#66d9ef">return</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;aceld&#34;</span>}
    <span style="color:#a6e22e">foo</span>(<span style="color:#a6e22e">s</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)
}
</code></pre></div><p>我们通过编译看看逃逸结果</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">aceld:test ldb$ go tool compile -m 7.go
7.go:5:6: can inline foo
7.go:11:5: inlining call to foo
7.go:13:13: inlining call to fmt.Println
7.go:5:10: a does not escape
7.go:10:15: <span style="color:#f92672">[]</span>string<span style="color:#f92672">{</span>...<span style="color:#f92672">}</span> escapes to heap
7.go:13:13: s escapes to heap
7.go:13:13: <span style="color:#f92672">[]</span>interface <span style="color:#f92672">{}{</span>...<span style="color:#f92672">}</span> does not escape
 :1: .this does not escape
</code></pre></div><p>我们看到 <code>s escapes to heap</code>，s被逃逸到堆上。</p>
<h3 id="案例八">案例八、<a hidden class="anchor" aria-hidden="true" href="#案例八">#</a></h3>
<p><code>chan []string</code>数据类型，想当前channel中传输<code>[]string{&quot;value&quot;}</code>会发生逃逸现象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> []<span style="color:#66d9ef">string</span>)

    <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;aceld&#34;</span>}

    <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
        <span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">s</span>
    }()
}
</code></pre></div><p>我们通过编译看看逃逸结果</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">aceld:test ldb$ go tool compile -m 8.go
8.go:8:5: can inline main.func1
8.go:6:15: <span style="color:#f92672">[]</span>string<span style="color:#f92672">{</span>...<span style="color:#f92672">}</span> escapes to heap
8.go:8:5: func literal escapes to heap
</code></pre></div><p>我们看到<code>[]string{...} escapes to heap</code>, s被逃逸到堆上。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://nicko-ch.github.io/tags/go/">Go</a></li>
      <li><a href="https://nicko-ch.github.io/tags/golang/">Golang</a></li>
    </ul>
  </footer>
</article>
    </main>
    <footer class="footer">
    <span>&copy; 2023 <a href="https://nicko-ch.github.io/">&gt; $ cd /home</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
