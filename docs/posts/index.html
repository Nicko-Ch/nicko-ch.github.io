<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | &gt; $ cd /home</title>
<meta name="keywords" content="" />
<meta name="description" content="Posts - &gt; $ cd /home">
<meta name="author" content="">
<link rel="canonical" href="https://nicko-ch.github.io/posts/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.0459a4ebf56f381ae411e97a494635ba7ce9db741ff9a2cfbf7e12366bf1e73d.css" integrity="sha256-BFmk6/VvOBrkEel6SUY1unzp23Qf&#43;aLPv34SNmvx5z0=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://nicko-ch.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://nicko-ch.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://nicko-ch.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://nicko-ch.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://nicko-ch.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.88.0" />
<link rel="alternate" type="application/rss+xml" href="https://nicko-ch.github.io/posts/index.xml">
<meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://nicko-ch.github.io/posts/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://nicko-ch.github.io/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://nicko-ch.github.io/" accesskey="h" title="&gt; $ cd /home (Alt + H)">&gt; $ cd /home</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://nicko-ch.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://nicko-ch.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://nicko-ch.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://nicko-ch.github.io/posts/" title="Posts">
                    <span class="active">Posts</span>
                </a>
            </li>
            <li>
                <a href="https://nicko-ch.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://nicko-ch.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="https://nicko-ch.github.io/">Home</a></div>
  <h1>Posts</h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>分布式缓存</h2>
  </header>
  <section class="entry-content">
    <p>分布式缓存 Hash算法 简述 对资源进行取模运算：hash(资源) % 机器数 = 余数
然后去余数对应的服务器存取资源
缺点：一旦机器数量变更，将导致所有缓存失效
一致性Hash 简述 设置一个Hash环，大小为2^32
对资源进行取模运算：hash(资源) % 2^32 = 余数
然后顺时针的往下寻找服务器
优点：相较于hash算法，激起数量的变更，一致性hash只会导致部分缓存失效
缺点：因为不均衡，产生hash偏斜，可能会导致大量缓存跑到某一台服务器
Hash偏斜 解决方法：新增虚拟节点，让分布尽可能均匀</p>
  </section>
  <footer class="entry-footer">December 3, 2022&nbsp;·&nbsp;1 min</footer>
  <a class="entry-link" aria-label="post link to 分布式缓存" href="https://nicko-ch.github.io/posts/solution/20221203-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>限流算法</h2>
  </header>
  <section class="entry-content">
    <p>限流算法 1 漏桶算法 假设当前请求b到来，at为上一次请求处理时间，w为剩余容量，c为总容量，r为滴漏速度
伪代码 when(b): bt = now() // b到来时间为当前时间 	wb = (bt - at) * r // b到来的过程量=（b时间 - 上一次请求时间）* 流速 	w = max(w - wb, 0) // 剩余容量 = 最大值（剩余容量 - wb带来的容量，0） 木桶剩余最小为0 if(w &lt; c) // 如果剩余容量未满 	w&#43;&#43; // 剩余容量&#43;&#43; 	return true else: return false 2 令牌桶算法 假设当前请求b到来，at为上一次请求处理时间，w为剩余容量，c为总容量，r为滴漏速度
伪代码 when(b): bt = now() // b到来时间为当前时间 	wb = (bt - at) * r // b到来的过程量=（b时间 - 上一次请求时间）* 流速 	w = min(w &#43; wb, c) // 剩余容量 = 最小值（剩余容量 &#43; wb带来的容量，c） if (w &gt; 1): // 如果桶内令牌大于1 	w-- // 令牌-- 	return true else: return false 3 比较 放入速度...</p>
  </section>
  <footer class="entry-footer">November 12, 2022&nbsp;·&nbsp;1 min</footer>
  <a class="entry-link" aria-label="post link to 限流算法" href="https://nicko-ch.github.io/posts/solution/20221112-%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>设计与实现</h2>
  </header>
  <section class="entry-content">
    <p>设计与实现 前言 查询数据类型 OBJECT ENCODING {key} 1. 基础数据类型 1.1 SDS 与 C字符串 区别 1.1.1 SDS简单动态字符串定义 struct sdshdr{ //记录buf数组中已使用字节的数量  //等于 SDS 保存字符串的长度  int len; //记录 buf 数组中未使用字节的数量  int free; //字节数组，用于保存字符串  char buf[]; } 1.1.2 可重用C函数 SDS遵循与C语言字符串一样的规则，以‘\0’(空字符)结尾，所以SDS可以直接重用部分C语言的字符串函数。（空字符不计入len属性，所以对于SDS使用者完全透明）
1.1.3 二进制安全 泛指二进制数据在传输、存储、读取的时候都不会被篡改，如C语言中的字符串类型必须为空字符（\0）结束，则后续如果跟有其他数据，则读取处理将会跟原数据不同，即非二进制安全
例如：
在C语言中读取会返回“Redis”，空字符往后的则被忽略。 而在Redis中读取会返回“Redis Cluster ”，以len属性判断字符串是否结束
1.1.4 获取长度 C语言字符串获取长度，需要遍历字符串中的每一位进行累加计算，时间复杂度为O(N)
SDS获取长度，只需要直接获取len属性，时间复杂度为O(1)
1.1.5 杜绝缓冲区溢出  C字符串中，如果未给变量申请足够的空间，进行了如srtcat复制操作，将可能导致新字符串过长，导致变量内存内容被覆盖。 与C语言不同，SDS会闲计算自身空间，如果不足会自动扩展。  1.1.6 空间预分配 为了防止频繁的进行空间分配，SDS每次扩容的时候都会进行一定的冗余扩充
 如果对 SDS 进行修改之后， SDS 的长度（也即是 len 属性的值）将小于 1 MB ， 那么程序分配和 len 属性同样大小的未使用空间， 这时 SDS len 属性的值将和 free 属性的值相同。 举个例子， 如果进行修改之后， SDS 的 len 将变成 13 字节， 那么程序也会分配13 字节的未使用空间， SDS 的 buf 数组的实际长度将变成 13 &#43; 13 &#43; 1 = 27 字节（额外的一字节用于保存空字符）。 如果对 SDS 进行修改之后， SDS 的长度将大于等于 1 MB ， 那么程序会分配 1 MB 的未使用空间。 举个例子， 如果进行修改之后， SDS 的 len 将变成 30 MB ， 那么程序会分配 1 MB 的未使用空间， SDS 的 buf 数组的实际长度将为 30 MB &#43; 1 MB &#43; 1 byte 。  1....</p>
  </section>
  <footer class="entry-footer">September 16, 2022&nbsp;·&nbsp;5 min</footer>
  <a class="entry-link" aria-label="post link to 设计与实现" href="https://nicko-ch.github.io/posts/redis/20220916-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>计算机考研408 - I/O多路复用</h2>
  </header>
  <section class="entry-content">
    <p>I/O多路复用 1、什么是I/O多路复用  **单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力**
 2、流？I/O操作？阻塞？ （1）流  可以进行I/O操作的内核对象 文件、管道、套接字…… 流的入口：文件描述符(fd)  （2）I/O操作 所有对流的读写操作，我们都可以称之为IO操作。
（3）阻塞 阻塞场景: 你有一份快递，家里有个座机，快递到了主动给你打电话，期间你可以休息。
非阻塞，忙轮询场景: 你性子比较急躁， 每分钟就要打电话询问快递小哥一次， 到底有没有到，快递员接你电话要停止运输，这样很耽误快递小哥的运输速度。
3、解决阻塞等待办法 （1）非阻塞、忙轮询 伪代码 while true { for i in 流[] { if i has 数据 { 读 或者 其他处理 } } } 特点  用户态不断请求内核态查看IO情况 请求间隔短会导致cpu无效占用率高 请求间隔长会导致io长时间无法处理  （2）select 伪代码 while true { select(流[]); //阻塞  //有消息抵达 	for i in 流[] { if i has 数据 { 读 或者 其他处理 } } } 特点  时间复杂度O(n) 开设一个代接收点，待内核态有io处理信号，则返回告诉用户 select只能通知用户IO事件发生，无法准确告诉是哪个IO流待处理，需要用户遍历查找 实现底层用的数组结构，理论上有最大连接数：1024(x86) 或 2048(x64) 每次调用select，都需要把集合fd从用户态拷贝到内核态  （3）poll 原理与select类似，但实现底层结构更换为链表，理论上没有最大连接数限制...</p>
  </section>
  <footer class="entry-footer">August 22, 2022&nbsp;·&nbsp;1 min</footer>
  <a class="entry-link" aria-label="post link to 计算机考研408 - I/O多路复用" href="https://nicko-ch.github.io/posts/computer-principles/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/20220822-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>算法系列 - 快速排序</h2>
  </header>
  <section class="entry-content">
    <p>描述 快速排序是对插入算法的一种优化，利用对问题的二分化，实现递归完成快速排序 ，在所有算法中二分化是最常用的方式，将问题尽量的分成两种情况加以分析， 最终以形成类似树的方式加以利用，因为在比较模型中的算法中，最快的排序时间复杂度为 O(log~n~).
原理  选取边界值：temp 遍历比较数组中每个值与边界值大小关系：小于边界值放小于数组，大于边界值放大于数组 递归排序大、小数组 合并返回当前已排完序数组  PS：注意递归结束条件，数组中长度小于2，代表
package main import &#34;fmt&#34; func main() { sortSlice := quickSort([]int{1, 9, 10, 30, 2, 5, 45, 8, 63, 234, 12}) fmt.Println(sortSlice) } func quickSort(arr []int) []int { if len(arr) &lt;= 2 { return arr } temp := arr[0] var low, high = make([]int, 0), make([]int, 0) for i := 1; i &lt; len(arr); i&#43;&#43; { if arr[i] &lt; temp { low = append(low, arr[i]) } else { high = append(high, arr[i]) } } lowSlice := quickSort(low) highSlice := quickSort(high) return append(append(lowSlice, temp), highSlice....</p>
  </section>
  <footer class="entry-footer">April 18, 2022&nbsp;·&nbsp;1 min</footer>
  <a class="entry-link" aria-label="post link to 算法系列 - 快速排序" href="https://nicko-ch.github.io/posts/computer-principles/%E7%AE%97%E6%B3%95/20220418-%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Kubernetes基础</h2>
  </header>
  <section class="entry-content">
    <p>1. 控制器类型 1.1 有状态服务 Statefulset  稳定持久化 稳定网络标志(地址) 有序部署 有序收缩(删除)  1.2 无状态服务 RC（ReplicationController） 副本数量与期望值之间的管理
RS（ReplicaSet） 功能类似于RC，但是多了集合式的标签选择器
Deployment 支持滚动更新以及回滚
DaemonSet 单例模式
确保Node上有且只运行一个同类型pod
Job 负责批处理任务，即仅执行一次的任务，它可以保证批处理任务一个或者多个Pod成功结束
Cron Job 周期性执行任务
2. 网络通讯方式 2.1 同 Pod 间不同容器间 IO
2.2 不同 Pod 间的通讯 同物理机 Docker0 网桥实现报文转发
不同物理机 flannel UDP 数据包二次封装</p>
  </section>
  <footer class="entry-footer">March 23, 2022&nbsp;·&nbsp;1 min</footer>
  <a class="entry-link" aria-label="post link to Kubernetes基础" href="https://nicko-ch.github.io/posts/kubernetes/20220323-kubernetes%E5%9F%BA%E7%A1%80/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Go高级编程 - 单元测试用例</h2>
  </header>
  <section class="entry-content">
    <p>单元测试用例 文件命名规则 单元测试需要创建单独的测试文件，不能在原有文件中书写，名字规则为 xxx_test.go。这个规则很好理解。
包命名规则 单元测试文件的包名为原文件的包名添加下划线接test，举例如下：
// 原文件包名：  package xxx // 单元测试文件包名：  package xxx_test 方法命名规则 单元测试文件中的测试方法和原文件中的待测试的方法名相对应，以Test开头，举例如下：
// 原文件方法： func Xxx(name string) error // 单元测试文件方法： func TestXxx() 方法参数 单元测试方法的参数必须是t *testing.T，举例如下：
func TestZipFiles(t *testing.T) { ... 命令行执行 *go test **-v** cdfPrint_test.go **-run** TestPrintCDF // **-v** 指定文件 // **-run** 指定函数* </p>
  </section>
  <footer class="entry-footer">March 21, 2022&nbsp;·&nbsp;1 min</footer>
  <a class="entry-link" aria-label="post link to Go高级编程 - 单元测试用例" href="https://nicko-ch.github.io/posts/golang/20220321-go%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Go高级编程 - Golang中Defer必掌握的7知识点</h2>
  </header>
  <section class="entry-content">
    <p>Golang中Defer必掌握的7知识点 知识点1：defer的执行顺序 多个defer出现的时候，它是一个“栈”的关系，也就是先进后出。一个函数中，写在前面的defer会比写在后面的defer调用的晚。
package main import &#34;fmt&#34; func main() { defer func1() defer func2() defer func3() } func func1() { fmt.Println(&#34;A&#34;) } func func2() { fmt.Println(&#34;B&#34;) } func func3() { fmt.Println(&#34;C&#34;) } 输出结果：
C B A 结论为：先压栈后出栈
知识点2：defer与return谁先谁后 package main import &#34;fmt&#34; func deferFunc() int { fmt.Println(&#34;defer func called&#34;) return 0 } func returnFunc() int { fmt.Println(&#34;return func called&#34;) return 0 } func returnAndDefer() int { defer deferFunc() return returnFunc() } func main() { returnAndDefer() } 输出结果：...</p>
  </section>
  <footer class="entry-footer">January 8, 2022&nbsp;·&nbsp;3 min</footer>
  <a class="entry-link" aria-label="post link to Go高级编程 - Golang中Defer必掌握的7知识点" href="https://nicko-ch.github.io/posts/golang/20220108-go%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-golang%E4%B8%ADdefer%E5%BF%85%E6%8E%8C%E6%8F%A1%E7%9A%847%E7%9F%A5%E8%AF%86%E7%82%B9/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Go高级编程 - Golang逃逸分析</h2>
  </header>
  <section class="entry-content">
    <p>Golang逃逸分析 1、 原理 go语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做**逃逸分析(escape analysis)**，**当发现变量的作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆。**
2、如何分析 2.1、案例 package main func foo(arg_val int) (*int) { var foo_val1 int = 11; var foo_val2 int = 12; var foo_val3 int = 13; var foo_val4 int = 14; var foo_val5 int = 15; //此处循环是防止go编译器将foo优化成inline(内联函数)  //如果是内联函数，main调用foo将是原地展开，所以foo_val1-5相当于main作用域的变量  //即使foo_val3发生逃逸，地址与其他也是连续的  for i := 0; i &lt; 5; i&#43;&#43; { println(&amp;arg_val, &amp;foo_val1, &amp;foo_val2, &amp;foo_val3, &amp;foo_val4, &amp;foo_val5) } //返回foo_val3给main函数  return &amp;foo_val3; } func main() { main_val := foo(666) println(*main_val, main_val) } 运行结果...</p>
  </section>
  <footer class="entry-footer">January 6, 2022&nbsp;·&nbsp;4 min</footer>
  <a class="entry-link" aria-label="post link to Go高级编程 - Golang逃逸分析" href="https://nicko-ch.github.io/posts/golang/20220106-go%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-golang%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Go高级编程 - 性能监测与优化实践方法</h2>
  </header>
  <section class="entry-content">
    <p>性能监测与优化实践方法 场景1：如何分析程序的运行时间与CPU利用率情况？ （1）shell内置time指令 $ time go run test2.go &amp;{{0 0} 张三 0} real	0m0.843s user	0m0.216s sys	0m0.389s  real ：从程序开始到结束，实际使用时间； user ：程序在用户态使用时间； sys ：程序在内核态使用时间。  一般情况下 real &gt;= user &#43; sys，因为系统还有其它进程(切换其他进程中间对于本进程会有空白期)。
（2）/user/bin/time 指令 使用时需要输入决定路径，带上参数-v
$ /usr/bin/time -v go run test2.go Command being timed: &#34;go run test2.go&#34; User time (seconds): 0.12 System time (seconds): 0.06 Percent of CPU this job got: 115% Elapsed (wall clock) time (h:mm:ss or m:ss): 0:00.16 Average shared text size (kbytes): 0 Average unshared data size (kbytes): 0 Average stack size (kbytes): 0 Average total size (kbytes): 0 Maximum resident set size (kbytes): 41172 Average resident set size (kbytes): 0 Major (requiring I/O) page faults: 1 Minor (reclaiming a frame) page faults: 15880 Voluntary context switches: 897 Involuntary context switches: 183 Swaps: 0 File system inputs: 256 File system outputs: 2664 Socket messages sent: 0 Socket messages received: 0 Signals delivered: 0 Page size (bytes): 4096 Exit status: 0  CPU占用率； 内存使用情况； Page Fault 情况； 进程切换情况； 文件系统IO； Socket 使用情况； ……  场景2：如何分析golang程序的内存使用情况？ （1）内存占用情况查看 场景例子代码demo...</p>
  </section>
  <footer class="entry-footer">January 1, 2022&nbsp;·&nbsp;8 min</footer>
  <a class="entry-link" aria-label="post link to Go高级编程 - 性能监测与优化实践方法" href="https://nicko-ch.github.io/posts/golang/20220101-go%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E4%B8%8E%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5%E6%96%B9%E6%B3%95/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://nicko-ch.github.io/posts/page/2/">Next Page »</a>
  </nav>
</footer>
    </main>
    <footer class="footer">
    <span>&copy; 2023 <a href="https://nicko-ch.github.io/">&gt; $ cd /home</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
