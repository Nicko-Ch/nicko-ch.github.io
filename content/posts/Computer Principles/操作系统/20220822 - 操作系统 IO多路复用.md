---
title: "计算机考研408 - I/O多路复用"
date: 2022-08-22
categories: "计算机考研408"
tags: 
  - 操作系统
draft: false
---

# I/O多路复用

# 1、什么是I/O多路复用

> `**单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力**`
> 

# 2、流？I/O操作？阻塞？

## （1）流

- 可以进行I/O操作的内核对象
- 文件、管道、套接字……
- 流的入口：文件描述符(fd)

## （2）I/O操作

所有对流的读写操作，我们都可以称之为IO操作。

![Untitled](../../static/images/20210822%20-%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/Untitled.png)

## （3）阻塞

**阻塞场景**: 你有一份快递，家里有个座机，快递到了主动给你打电话，期间你可以休息。

**非阻塞，忙轮询场景**: 你性子比较急躁， 每分钟就要打电话询问快递小哥一次， 到底有没有到，快递员接你电话要停止运输，这样很耽误快递小哥的运输速度。

# 3、解决阻塞等待办法

## （1）非阻塞、忙轮询

### 伪代码

```go
while true {
	for i in 流[] {
		if i has 数据 {
			读 或者 其他处理
		}
	}
}
```

### 特点

- 用户态不断请求内核态查看IO情况
- 请求间隔短会导致cpu无效占用率高
- 请求间隔长会导致io长时间无法处理

## （2）select

### 伪代码

```go
while true {
	select(流[]); //阻塞

  //有消息抵达
	for i in 流[] {
		if i has 数据 {
			读 或者 其他处理
		}
	}
}
```

### 特点

- 时间复杂度`O(n)`
- 开设一个代接收点，待内核态有io处理信号，则返回告诉用户
- select只能通知用户IO事件发生，无法准确告诉是哪个IO流待处理，需要用户遍历查找
- 实现底层用的数组结构，理论上有最大连接数：`1024(x86)` 或 `2048(x64)`
- 每次调用select，都需要把集合fd从用户态拷贝到内核态

## （3）poll

原理与select类似，但实现底层结构更换为链表，理论上没有最大连接数限制

## （4）epoll

### 伪代码

```go
while true {
	可处理的流[] = epoll_wait(epoll_fd); //阻塞

  //有消息抵达，全部放在 “可处理的流[]”中
	for i in 可处理的流[] {
		读 或者 其他处理
	}
}
```

### 触发方式

**(1) 水平触发**

水平触发的主要特点是，如果用户在监听`epoll`事件，当内核有事件的时候，会拷贝给用户态事件，但是**如果用户只处理了一次，那么剩下没有处理的会在下一次epoll_wait再次返回该事件**。

**(2) 边缘触发**

边缘触发，相对跟水平触发相反，当内核有事件到达， 只会通知用户一次，至于用户处理还是不处理，以后将不会再通知。这样减少了拷贝过程，增加了性能，但是相对来说，如果用户马虎忘记处理，将会产生事件丢的情况。

### 特点

- 时间复杂度`O(1)`
- 底层实现`哈希表`
- 事件通知，系统注册的回调函数被触发，将就绪fd防盗rdlist里面，用户可直接处理io请求
- 调用epoll_ctl时拷贝进内核并保存，之后每次epoll_wait不拷贝

## （5）select、poll与epoll区别

| \ | select | poll | epoll |
| --- | --- | --- | --- |
| 操作方式 | 遍历 | 遍历 | 回调 |
| 底层实现 | 数组 | 链表 | 哈希表 |
| IO效率 | 每次调用都进行线性遍历，时间复杂度为O(n) | 每次调用都进行线性遍历，时间复杂度为O(n) | 事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到rdllist里面。时间复杂度O(1) |
| 最大连接数 | 1024（x86）或 2048（x64） | 无上限 | 无上限 |
| fd拷贝 | 每次调用select，都需要把fd集合从用户态拷贝到内核态 | 每次调用poll，都需要把fd集合从用户态拷贝到内核态 | 调用epoll_ctl时拷贝进内核并保存，之后每次epoll_wait不拷贝 |