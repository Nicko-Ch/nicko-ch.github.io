---
title: "Redis应用与实战"
date: 2022-12-20
categories: "Redis"
tags: 
  - Redis
draft: false
---

# 应用与实战

# Redis分布式锁

## Redlock算法

Redlock 算法是 Redis 的作者 Antirez 提出的一种分布式锁的算法，Redlock 算法的基本思想是，使用多个 Redis 实例来存储锁，客户端需要同时向多个实例请求加锁和解锁，只有当大多数实例同意时，才认为操作成功。

Redlock 算法的具体步骤如下：

- 加锁：客户端获取当前时间戳，然后依次向 N 个 Redis 实例发送 SETNX 命令，将 key 设置为 lock，value 设置为一个随机字符串，并设置一个过期时间。如果向某个实例发送命令失败，就立即重试，直到成功或超时。然后客户端计算从获取时间戳到完成加锁的总耗时，如果超过了过期时间的一半，就认为加锁失败；否则，如果成功加锁的实例数超过了 N/2，就认为加锁成功，并返回 value；否则，就认为加锁失败，并向所有实例发送 DEL 命令，释放锁。
- 解锁：客户端向所有实例发送 GET 命令，获取 key 的值，并与自己保存的随机字符串比较。如果相同，表示是自己加的锁，就可以向所有实例发送 DEL 命令，删除 key，释放锁；如果不同，表示是别人加的锁，就不做任何操作。

Redlock 算法的优点是，它可以容忍少数实例故障或网络分区，只要大多数实例正常工作，就可以保证锁的正确性。它也可以避免单点故障导致的死锁。它的缺点是，它需要多个 Redis 实例和多次网络通信，可能会增加复杂度和开销。它也不能完全消除时钟漂移的影响，只能尽量减小其概率和影响。

> 简化下步骤就是：
1. 按顺序向5个master节点请求加锁
2. 根据设置的超时时间来判断，是不是要跳过该master节点。
3. 如果大于等于三个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功啦。
4. 如果获取锁失败，解锁！
> 

# 什么是缓存穿透、缓存雪崩、缓存击穿

## 缓存穿透

指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，进而给数据库带来压力。

- 如故意查询某错误值，直接穿透缓存层，导致DB压力过大

> 解决方案：
1、对接口非法参数进行校验；
2、如果数据库为空，也需要缓存一个空值，设置有效时间；
3、使用布隆过滤器快速判断数据是否存在；
> 

## 缓存雪崩

指缓存中数据大批量到过期时间，而查询数据量巨大，请求都直接访问数据库，引起数据库压力过大甚至down机。

- 缓存雪奔一般是由于大量数据同时过期造成的，对于这个原因，可通过均匀设置过期时间解决，即让过期时间相对离散一点。
- Redis 故障宕机也可能引起缓存雪奔。

> 解决方案：
1、如采用一个较大固定值+一个较小的随机值，5小时+0到1800秒酱紫；
2、对于故障宕机情况，使用RDB+AOF快速恢复；
> 

## 缓存击穿

指热点key在某个时间点过期的时候，而恰好在这个时间点对这个Key有大量的并发请求过来，从而大量的请求打到db。

- 缓存击穿与缓存雪崩的区别：`击穿是单热key失效，而雪崩是大量key集体失效`

> 解决方案：
1、使用分布式互斥锁更新数据，抢不到锁自旋等待；
2、热点数据不设置过期时间，待业务更新通过canel等插件触发更新；
> 

# ****什么是热Key问题，如何解决热key问题****

如果某一热点key的请求到服务器主机时，由于请求量特别大，可能会导致主机资源不足，甚至宕机，从而影响正常的服务。

- 用户消费的数据远大于生产的数据，如秒杀、热点新闻等读多写少的场景。
- 请求分片集中，超过单Redi服务器的性能，比如固定名称key，Hash落入同一台服务器，瞬间访问量极大，超过机器瓶颈，产生热点Key问题。

> 解决方案：
1、Redis集群扩容：增加分片副本，均衡读流量；
2、使用一致性hash算法，解决缓存偏斜问题；
> 

# ****Redis 过期策略和内存淘汰策略****

## ****过期策略****

### **定时过期**

> `每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即对key进行清除。`该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。
> 

### **惰性过期**

> `只有当访问一个key时，才会判断该key是否已过期，过期则清除。`该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。
> 

### **定期过期**

> `每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。`该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。
> 
> 
> expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。
> 

Redis中同时使用了**`惰性过期`**和**`定期过期`**两种过期策略。

但是仍可能在内存大量读写的情况下，遗留大量已过期数据，仍占用内存，这种情况下为了避免redis宕机，redis有8种**内存淘汰策略**兜底~

## 内存淘汰策略

1. volatile-lru：当内存不足以容纳新写入数据时，从设置了过期时间的key中使用LRU（最近最少使用）算法进行淘汰；
2. allkeys-lru：当内存不足以容纳新写入数据时，从所有key中使用LRU（最近最少使用）算法进行淘汰。
3. volatile-lfu：4.0版本新增，当内存不足以容纳新写入数据时，在过期的key中，使用LFU算法进行删除key。
4. allkeys-lfu：4.0版本新增，当内存不足以容纳新写入数据时，从所有key中使用LFU算法进行淘汰；
5. volatile-random：当内存不足以容纳新写入数据时，从设置了过期时间的key中，随机淘汰数据；。
6. allkeys-random：当内存不足以容纳新写入数据时，从所有key中随机淘汰数据。
7. volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的key中，根据过期时间进行淘汰，越早过期的优先被淘汰；
8. noeviction：默认策略，当内存不足以容纳新写入数据时，新写入操作会报错。

# 什么是Redisson？说说它的原理

Redisson解决了，`分布式锁`可能存在锁`过期释放，业务没执行完`的问题。

![Untitled](../../static/images/20221220%20-%20%E5%BA%94%E7%94%A8%E4%B8%8E%E5%AE%9E%E6%88%98/Untitled.png)

只要线程一加锁成功，就会启动一个`watch dog`看门狗，它是一个后台线程，会每隔10秒检查一下，如果线程1还持有锁，那么就会不断的延长锁key的生存时间。因此，Redisson就是使用watch dog解决了**锁过期释放，业务没执行完**问题。

# Mysql与Redis如何保证数据一致性

通过订阅biglog异步删除缓存

![Untitled](../../static/images/20221220%20-%20%E5%BA%94%E7%94%A8%E4%B8%8E%E5%AE%9E%E6%88%98/Untitled%201.png)

步骤如下：

1. 修改DB
2. canal订阅binlog，感知数据变更，发送请求至MQ
3. MQ异步更新缓存

## Canal

Canal是阿里开源的用于订阅Mysql中的Binlog中间件，从而触发后续开发操作

**原理为：Mysql主备复制**

![Untitled](../../static/images/20221220%20-%20%E5%BA%94%E7%94%A8%E4%B8%8E%E5%AE%9E%E6%88%98/Untitled%202.png)

# ****在生成 RDB期间，Redis 可以同时处理写请求么？****

**可以的**，Redis提供两个指令生成RDB，分别是**save和bgsave**。

- 如果是save指令，会阻塞，因为是主线程执行的。
- 如果是bgsave指令，是fork一个子进程来写入RDB文件的，快照持久化完全交给子进程来处理，父进程则可以继续处理客户端的请求。

# 布隆过滤器

布隆过滤器的主要作用是：快速判断元素是否在当前集合中

**判断是否存在**：预分配一个很长的`bitmap位图`作为集合，对元素进行`哈希散列`运算，得到一串01数据，然后与集合进行`“与”`运算，结果与01数据串相同，即`大概率存在`，反之即`不存在`

**新增元素进集合**：对元素进行`哈希散列`运算，得到一串01数据串，然后与集合进行`”或“`运算，即可得到新集合位图

![Untitled](../../static/images/20221220%20-%20%E5%BA%94%E7%94%A8%E4%B8%8E%E5%AE%9E%E6%88%98/Untitled%203.png)